using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System.Threading.Tasks;
using VerifyXunit;
using Xunit;
using Xunit.Abstractions;
using LazinatorGenerator.Generator;
using System.Runtime.CompilerServices;
using VerifyTests;
using System.Collections.Generic;
using Lazinator.Attributes;
using LazinatorTests.Support;
using System.Linq;
using FluentAssertions;
using System.IO;
using Microsoft.VisualStudio.TestPlatform.CommunicationUtilities.Resources;
using System;

namespace LazinatorTests.Tests
{
    [UsesVerify]
    public class GeneratorTests
    {
        [Fact]
        public Task UseGeneratorForSimpleILazinator()
        {        // The source code to test
            var interfaceSource = @"
using Lazinator.Attributes;

namespace MyCode
{
    [Lazinator((int)1)]
    public interface IMyExample
    {
        int MyInt { get; set; }
    }
}";

            var classSource = @"
using Lazinator.Attributes;

namespace MyCode
{
    public partial class MyExample : IMyExample
    {
    }
}";

            var sources = new List<(string filename, string text)>()
            {
                ("IMyExample.cs", interfaceSource),
                ("MyExample.cs", classSource)
            };

            var result = Generate(sources);

            var soleSource = result.outputs.Single();

            // Check to make sure that some source generation occurred.
            soleSource.text.Contains("[Autogenerated]").Should().BeTrue();
            soleSource.text.Contains("partial class").Should().BeTrue();

            // Use verify to snapshot test the source generator output!
            // return Verifier.Verify(driver);

            return Task.CompletedTask;
        }

        [Fact]
        public Task CanRegenerateCollectionsProject()
        {
            string projectName = "Lazinator.Collections";
            string projectPath = ReadCodeFile.GetCodeBasePath(projectName);
            var sourceFiles = GetAllCsFiles(projectPath).ToList();
            var handWritten = sourceFiles.Where(x => !x.Path.EndsWith(".g.cs") && !x.Path.EndsWith(".laz.cs")).ToList();
            var autogeneratedOriginals = sourceFiles.Where(x => x.Path.EndsWith(".g.cs") || x.Path.EndsWith(".laz.cs")).ToList();
            
            var result = Generate(handWritten);

            result.outputs.Count().Should().Be(autogeneratedOriginals.Count());

            var outputsOrdered = result.outputs.OrderBy(x => x.text).ToList();
            var originalsOrdered = autogeneratedOriginals.OrderBy(x => x.Text).ToList();
            for (int i = 0; i < outputsOrdered.Count(); i++)
            {
                outputsOrdered[i].text.Should().Be(originalsOrdered[i].Text);
            }

            // DEBUG TODO2 -- should also do other projects besides Lazinator.Collections.
            throw new System.Exception("DEBUG TODO2");

            return Task.CompletedTask;
        }
        
        [Fact]
        public Task SourceGeneratorProvidesDiagnostics()
        {
            throw new NotImplementedException();
        }
        
        
        private static IEnumerable<(string Path, string Text)> GetAllCsFiles(string rootFolderPath)
        {
            var csFiles = Directory.EnumerateFiles(rootFolderPath, "*.cs", SearchOption.AllDirectories);

            foreach (var csFile in csFiles)
            {
                string fileText = File.ReadAllText(csFile);

                yield return (csFile, fileText);
            }
        }

        private static (LazinatorIncrementalGenerator generator, CSharpCompilation compilation, GeneratorDriver driver, List<(string path, string text)> outputs) Generate(IEnumerable<(string filename, string text)> sources)
        {
            // Parse the provided string into a C# syntax tree
            IEnumerable<SyntaxTree> syntaxTrees = sources.Select(x => CSharpSyntaxTree.ParseText(x.text, path: x.filename)).ToArray();

            // Create references for assemblies we required
            IEnumerable <PortableExecutableReference> references = AdhocWorkspaceManager.GetProjectReferences();

            // Create a Roslyn compilation for the syntax tree.
            CSharpCompilation compilation = CSharpCompilation.Create(
                assemblyName: "Tests",
                syntaxTrees: syntaxTrees,
                references: references
                );


            // Create an instance of our incremental source generator
            var generator = new LazinatorIncrementalGenerator();

            // The GeneratorDriver is used to run our generator against a compilation
            GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

            // Run the source generator!
            driver = driver.RunGenerators(compilation);

            // Look at the resulting source file
            List<(string path, string text)> outputs = driver.GetRunResult().Results[0].GeneratedSources.Select(x => (x.SyntaxTree.FilePath, x.SourceText.ToString())).ToList();
            return (generator, compilation, driver, outputs);
        }


    }

    public static class ModuleInitializer
    {
        [ModuleInitializer]
        public static void Init()
        {
            VerifySourceGenerators.Enable();
        }
    }
}
