using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System.Threading.Tasks;
using VerifyXunit;
using Xunit;
using Xunit.Abstractions;
using LazinatorGenerator.Generator;
using System.Runtime.CompilerServices;
using VerifyTests;
using System.Collections.Generic;
using Lazinator.Attributes;
using LazinatorTests.Support;
using System.Linq;
using FluentAssertions;
using System.IO;
using Microsoft.VisualStudio.TestPlatform.CommunicationUtilities.Resources;
using System;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis.Text;
using System.Threading;
using System.Reflection.Emit;

namespace LazinatorTests.Tests
{
    [UsesVerify]
    public class GeneratorTests
    {

        [Fact]
        public Task GeneratorForSimpleLazinator_ProducesCode()
        {
            RunGeneratorForSimpleLazinator(out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);

            // Check to make sure that some source generation occurred.
            soleSource.text.Contains("[Autogenerated]").Should().BeTrue();
            soleSource.text.Contains("partial class").Should().BeTrue();

            return Task.CompletedTask;
        }

        [Fact]
        public Task GeneratorForSimpleLazinator_DiagnosticBeforeGeneratedCodeAdded()
        {

            RunGeneratorForSimpleLazinator(out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);


            var diagnosticsWithoutGeneratedSources = executionResult.compilation.GetDiagnostics().ToList();
            // Because we haven't yet added the syntax trees for the new file to the compilation, we should still have a diagnostic (for not implementing the interface property).
            diagnosticsWithoutGeneratedSources.Count().Should().Be(1);

            return Task.CompletedTask;
        }

        [Fact]
        public Task GeneratorForSimpleLazinator_DiagnosticAfterGeneratedCodeAdded()
        {
            RunGeneratorForSimpleLazinator(out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);
            
            // Update compilation and get the diagnostics with the generated sources
            var executionResultWithGeneratedSources = AddGeneratedFilesToCompilation(executionResult);
            var diagnosticsWithGeneratedSources = executionResultWithGeneratedSources.compilation.GetDiagnostics().ToList();
            diagnosticsWithGeneratedSources.Count().Should().Be(0);

            return Task.CompletedTask;
        }

        private static void RunGeneratorForSimpleLazinator(out GeneratorExecutionResult executionResult, out (string path, string text) soleSource)
        {
            List<(string filename, string text)> sources = GetSourcesForSimpleLazinator();

            executionResult = ExecuteGeneration(sources);
            soleSource = executionResult.outputs.Single();
        }

        [Fact]
        public Task SourceGeneratorProvidesDiagnosticForUsingNonLazinatorSource()
        {
            List<(string filename, string text)> sources = GetSourcesUsingNonLazinator();

            var result = ExecuteGeneration(sources);
            var diagnostics = result.compilation.GetDiagnostics();

            diagnostics.Count().Should().BeGreaterThan(0);
            diagnostics.Any(x => x.ToString().Contains("MyNonLazinator")).Should().BeTrue();

            return Task.CompletedTask;
        }
        

        [Theory]
        [InlineData("Lazinator")]
        [InlineData("Lazinator.Collections")]
        [InlineData("LazinatorTests")]
        public Task SourceGeneratorCanMatchExistingLazinatorFiles(string projectName)
        {
            string projectPath = ReadCodeFile.GetCodeBasePath(projectName);
            var lazinatorConfigFiles = GetMatchingFiles(projectPath, "LazinatorConfig.json").ToList();
            var lazinatorConfigFiles2 = GetMatchingFiles(projectPath, "Lazinatorconfig.json").ToList();
            lazinatorConfigFiles.AddRange(lazinatorConfigFiles2);
            var sourceFiles = GetMatchingFiles(projectPath).ToList();
            var handWritten = sourceFiles.Where(x => !x.Path.EndsWith(".g.cs") && !x.Path.EndsWith(".laz.cs")).ToList();
            var autogeneratedOriginals = sourceFiles.Where(x => x.Path.EndsWith(".g.cs") || x.Path.EndsWith(".laz.cs")).ToList();

            var executionResult = ExecuteGeneration(handWritten, lazinatorConfigFiles);

            var outputNames = String.Join("\n", executionResult.outputs.Select(x => x.path)) ;
            var originalNames = String.Join("\n", autogeneratedOriginals.Select(x => x.Path));
            executionResult.outputs.Count().Should().Be(autogeneratedOriginals.Count());

            var outputsOrdered = executionResult.outputs.OrderBy(x => x.text).ToList();
            var originalsOrdered = autogeneratedOriginals.OrderBy(x => x.Text).ToList();
            for (int i = 0; i < outputsOrdered.Count(); i++)
            {
                outputsOrdered[i].text.Should().Be(originalsOrdered[i].Text);
            }

            return Task.CompletedTask;
        }
        
        private static IEnumerable<(string Path, string Text)> GetMatchingFiles(string rootFolderPath, string searchPattern = "*.cs")
        {
            var matching = Directory.EnumerateFiles(rootFolderPath, searchPattern, SearchOption.AllDirectories);

            foreach (var csFile in matching)
            {
                string fileText = File.ReadAllText(csFile);

                yield return (csFile, fileText);
            }
        }

        #region Sources for generator tests


        private static List<(string filename, string text)> GetSourcesForSimpleLazinator()
        {
            var mainProgramSource = @"
namespace MyCode
{
    public class Program
    {
        public static void Main(string[] args)
        {
        }
    }
}";


            var interfaceSource = @"
using Lazinator.Attributes;

namespace MyCode
{
    [Lazinator((int)1)]
    public interface IMyExample
    {
        int MyInt { get; set; }
    }
}";

            var classSource = @"
namespace MyCode
{
    public partial class MyExample : IMyExample
    {
    }
}";

            var sources = new List<(string filename, string text)>()
            {
                ("Program.cs", mainProgramSource),
                ("IMyExample.cs", interfaceSource),
                ("MyExample.cs", classSource)
            };
            return sources;
        }

        private static List<(string filename, string text)> GetSourcesUsingNonLazinator()
        {
            var mainProgramSource = @"
namespace MyCode
{
    public class Program
    {
        public static void Main(string[] args)
        {
        }
    }
}";

            // we'll do something wrong by having a Lazinator interface refer to a non-Lazinator class.
            var nonlazinatorSource = @"
namespace MyCode
{
    public class MyNonLazinator
    {
    
    }
}
";

            // The source code to test
            var interfaceSource = @"
using Lazinator.Attributes;

namespace MyCode
{
    [Lazinator((int)1)]
    public interface IMyExample
    {
        MyNonLazinator MyMistake { get; set; }
    }
}";

            var classSource = @"
namespace MyCode
{
    public partial class MyExample : IMyExample
    {
    }
}";

            var sources = new List<(string filename, string text)>()
            {
                ("Program.cs", mainProgramSource),
                ("IMyExample.cs", interfaceSource),
                ("MyExample.cs", classSource)
            };
            return sources;
        }

        #endregion

        #region Generator execution

        public record GeneratorExecutionResult(LazinatorIncrementalGenerator generator, CSharpCompilation compilation, GeneratorDriver driver, List<(string path, string text)> outputs)
        {

        }

        private static GeneratorExecutionResult ExecuteGeneration(IEnumerable<(string path, string text)> sources, IEnumerable<(string path, string text)> additionalTexts = null)
        {
            // Parse the provided string into a C# syntax tree
            IEnumerable<SyntaxTree> syntaxTrees = sources.Select(x => CSharpSyntaxTree.ParseText(x.text, path: x.path)).ToArray();

            // Create references for assemblies we required
            IEnumerable <PortableExecutableReference> references = AdhocWorkspaceManager.GetProjectReferences();

            // Create a Roslyn compilation for the syntax tree.
            CSharpCompilation compilation = CSharpCompilation.Create(
                assemblyName: "Tests",
                syntaxTrees: syntaxTrees,
                references: references
                );

            // Create an instance of our incremental source generator
            var generator = new LazinatorIncrementalGenerator();

            // The GeneratorDriver is used to run our generator against a compilation
            GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
            if (additionalTexts != null)
            {
                var additionalTexts2 = ImmutableArray.CreateRange(additionalTexts.Select(x => (AdditionalText)new CustomAdditionalText(x.path, x.text)));
                driver = driver.AddAdditionalTexts(additionalTexts2);
            }

            // Run the source generator!
            driver = driver.RunGenerators(compilation);

            // Look at the resulting source file
            List<(string path, string text)> outputs = driver.GetRunResult().Results[0].GeneratedSources.Select(x => (x.SyntaxTree.FilePath, x.SourceText.ToString())).ToList();
            return new GeneratorExecutionResult(generator, compilation, driver, outputs);
        }

        private static GeneratorExecutionResult AddGeneratedFilesToCompilation(GeneratorExecutionResult executionResult)
        {
            // Add the generated sources to the compilation
            GeneratorDriverRunResult overallRunResult = executionResult.driver.GetRunResult();
            foreach (var specificRunResult in overallRunResult.Results)
            {
                foreach (var source in specificRunResult.GeneratedSources)
                {
                    SyntaxTree tree = CSharpSyntaxTree.ParseText(source.SourceText);
                    executionResult = executionResult with { compilation = executionResult.compilation.AddSyntaxTrees(tree) };
                }
            }
            return executionResult;
        }


    }

    public static class ModuleInitializer
    {
        // DEBUG -- I think this whole thing can be deleted and we can remove Verify.SourceGenerators
        [ModuleInitializer]
        public static void Init()
        {
            VerifySourceGenerators.Enable();
        }
    }

    public class CustomAdditionalText : AdditionalText
    {
        private readonly string _text;

        public override string Path { get; }

        public CustomAdditionalText(string path, string text)
        {
            Path = path;
            _text = text ?? File.ReadAllText(path);
        }

        public override SourceText GetText(CancellationToken cancellationToken = new CancellationToken())
        {
            return SourceText.From(_text);
        }

        #endregion
    }
}
