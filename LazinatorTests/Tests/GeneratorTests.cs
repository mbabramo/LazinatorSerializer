using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System.Threading.Tasks;
using VerifyXunit;
using Xunit;
using Xunit.Abstractions;
using LazinatorGenerator.Generator;
using System.Runtime.CompilerServices;
using VerifyTests;
using System.Collections.Generic;
using Lazinator.Attributes;
using LazinatorTests.Support;
using System.Linq;
using FluentAssertions;
using System.IO;
using Microsoft.VisualStudio.TestPlatform.CommunicationUtilities.Resources;
using System;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis.Text;
using System.Threading;
using System.Reflection.Emit;
using LazinatorGenerator.Support;

namespace LazinatorTests.Tests
{
    [UsesVerify]
    public class GeneratorTests
    {

        [Fact]
        public Task GeneratorForSimpleLazinator_ProducesCode()
        {
            RunGeneratorForSimpleLazinator(new FakeDateTimeNow(), out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);

            // Check to make sure that some source generation occurred.
            soleSource.text.Contains("[Autogenerated]").Should().BeTrue();
            soleSource.text.Contains("partial class").Should().BeTrue();

            return Task.CompletedTask;
        }

        [Fact]
        public Task GeneratorForSimpleLazinator_DiagnosticBeforeGeneratedCodeAdded()
        {

            RunGeneratorForSimpleLazinator(new FakeDateTimeNow(), out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);


            var diagnosticsWithoutGeneratedSources = executionResult.compilation.GetDiagnostics().ToList();
            // Because we haven't yet added the syntax trees for the new file to the compilation, we should still have a diagnostic (for not implementing the interface property).
            diagnosticsWithoutGeneratedSources.Count().Should().Be(1);

            return Task.CompletedTask;
        }

        [Fact]
        public Task GeneratorForSimpleLazinator_DiagnosticAfterGeneratedCodeAdded()
        {
            RunGeneratorForSimpleLazinator(new FakeDateTimeNow(), out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);
            
            // Update compilation and get the diagnostics with the generated sources
            var executionResultWithGeneratedSources = AddGeneratedFilesToCompilation(executionResult);
            var diagnosticsWithGeneratedSources = executionResultWithGeneratedSources.compilation.GetDiagnostics().ToList();
            diagnosticsWithGeneratedSources.Count().Should().Be(0);

            return Task.CompletedTask;
        }

        [Fact]
        public Task GeneratorForSimpleLazinator_PipelineCaches()
        {

            RunGeneratorForSimpleLazinator(new FakeDateTimeNow(), out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);

            var filesGeneratedInitially = executionResult.driver.GetRunResult().Results.SelectMany(x => x.GeneratedSources).ToList();

            // Update compilation and get the diagnostics with the generated sources
            var executionResultWithGeneratedSources = AddGeneratedFilesToCompilation(executionResult);
            executionResultWithGeneratedSources.driver.RunGenerators(executionResultWithGeneratedSources.compilation); // rerun generators
            var filesGenerated = executionResultWithGeneratedSources.driver.GetRunResult().Results.SelectMany(x => x.GeneratedSources).ToList();

            bool exactMatch = filesGenerated[0].SourceText.ToString() == filesGeneratedInitially[0].SourceText.ToString(); // checks whether files match, including the date and version number.
            exactMatch.Should().BeTrue();

            return Task.CompletedTask;
        }

        [Fact]
        public Task GeneratorForSimpleLazinator_NoCachingWithConfigChange()
        {
            var dateTimeNowProvider = new FakeDateTimeNow();
            RunGeneratorForSimpleLazinator(dateTimeNowProvider, out GeneratorExecutionResult executionResult, out (string path, string text) soleSource);

            var filesGeneratedInitially = executionResult.driver.GetRunResult().Results.SelectMany(x => x.GeneratedSources).ToList();

            dateTimeNowProvider.Advance(TimeSpan.FromMinutes(1));

            //RunGeneratorForSimpleLazinator(dateTimeNowProvider, out executionResult, out soleSource); // DEBUG
            //var DEBUG2 = executionResult.driver.GetRunResult().Results.SelectMany(x => x.GeneratedSources).ToList(); // DEBUG

            // Update compilation
            var executionResultWithGeneratedSources = AddGeneratedFilesToCompilation(executionResult);
            List<(string path, string text)> additionalTexts = new List<(string path, string text)>() { ("LazinatorConfig.json", @"{
  ""Comment"": ""This is a change that should trigger regeneration of code.""
}") };



            executionResultWithGeneratedSources = executionResultWithGeneratedSources with { driver = AddAdditionalTextsToDriver(additionalTexts, executionResultWithGeneratedSources.driver) }; 

            var updatedDriver = executionResultWithGeneratedSources.driver.RunGenerators(executionResultWithGeneratedSources.compilation); // rerun generators
            var filesGenerated = updatedDriver.GetRunResult().Results.SelectMany(x => x.GeneratedSources).ToList();

            bool exactMatch = filesGenerated[0].SourceText.ToString() == filesGeneratedInitially[0].SourceText.ToString(); // checks whether files match, including the date and version number.
            exactMatch.Should().BeFalse();
            // DEBUG -- this isn't working. Why? PostGenerationInfo is being created both times, so it's not actually caching. But the new version doesn't appear here. Could it be something to do with what I'm calling. I think that one thing to do would be to actually create the source generator. 

            return Task.CompletedTask;
        }

        [Fact]
        public Task Generator_CachingWhenChangeMadeToIrrelevantClass()
        {
            throw new NotImplementedException();
        }

        [Fact]
        public Task Generator_NoCachingWhenChangeMadeToBaseClass()
        {
            throw new NotImplementedException();
        }

        [Fact]
        public Task Generator_NoCachingWhenChangeMadeToPropertyName()
        {
            throw new NotImplementedException();
        }

        private static void RunGeneratorForSimpleLazinator(IDateTimeNow dateTimeNowProvider, out GeneratorExecutionResult executionResult, out (string path, string text) soleSource)
        {
            List<(string path, string text)> sources = GetSourcesForSimpleLazinator();

            executionResult = ExecuteGeneration(sources, null, dateTimeNowProvider);
            soleSource = executionResult.outputs.Single();
        }

        [Fact]
        public Task SourceGeneratorProvidesDiagnosticForUsingNonLazinatorSource()
        {
            List<(string path, string text)> sources = GetSourcesUsingNonLazinator();

            var result = ExecuteGeneration(sources, null, new FakeDateTimeNow());
            var diagnostics = result.compilation.GetDiagnostics();

            diagnostics.Count().Should().BeGreaterThan(0);
            diagnostics.Any(x => x.ToString().Contains("MyNonLazinator")).Should().BeTrue();

            return Task.CompletedTask;
        }

        [Theory]
        [InlineData("Lazinator")]
        [InlineData("Lazinator.Collections")]
        [InlineData("LazinatorTests")]
        public Task SourceGeneratorCanMatchExistingLazinatorFiles(string projectName)
        {
            string projectPath = ReadCodeFile.GetCodeBasePath(projectName);
            var lazinatorConfigFiles = GetMatchingFiles(projectPath, "LazinatorConfig.json").ToList();
            var lazinatorConfigFiles2 = GetMatchingFiles(projectPath, "Lazinatorconfig.json").ToList();
            lazinatorConfigFiles.AddRange(lazinatorConfigFiles2);
            var sourceFiles = GetMatchingFiles(projectPath).ToList();
            var handWritten = sourceFiles.Where(x => !x.Path.EndsWith(".g.cs") && !x.Path.EndsWith(".laz.cs")).ToList();
            var autogeneratedOriginals = sourceFiles.Where(x => x.Path.EndsWith(".g.cs") || x.Path.EndsWith(".laz.cs")).ToList();

            var executionResult = ExecuteGeneration(handWritten, lazinatorConfigFiles, new RealDateTimeNow());

            var outputNames = String.Join("\n", executionResult.outputs.Select(x => x.path)) ;
            var originalNames = String.Join("\n", autogeneratedOriginals.Select(x => x.Path));
            executionResult.outputs.Count().Should().Be(autogeneratedOriginals.Count());

            var outputsOrdered = executionResult.outputs.OrderBy(x => x.text).ToList();
            var originalsOrdered = autogeneratedOriginals.OrderBy(x => x.Text).ToList();
            for (int i = 0; i < outputsOrdered.Count(); i++)
            {
                bool matchesIgnoringGenerationInfo = CompareExcludingLinesWithPrefix(outputsOrdered[i].text, originalsOrdered[i].Text, "//     This code was generated by the Lazinator tool");
                matchesIgnoringGenerationInfo.Should().Be(true);
            }

            return Task.CompletedTask;
        }
        
        private static IEnumerable<(string Path, string Text)> GetMatchingFiles(string rootFolderPath, string searchPattern = "*.cs")
        {
            var matching = Directory.EnumerateFiles(rootFolderPath, searchPattern, SearchOption.AllDirectories);

            foreach (var csFile in matching)
            {
                string fileText = File.ReadAllText(csFile);

                yield return (csFile, fileText);
            }
        }

        public static bool CompareExcludingLinesWithPrefix(string s1, string s2, string prefix)
        {
            using (var reader1 = new StringReader(s1))
            using (var reader2 = new StringReader(s2))
            {
                string line1 = reader1.ReadLine();
                string line2 = reader2.ReadLine();

                while (line1 != null || line2 != null)
                {
                    // Skip lines that start with the prefix
                    if (line1 != null && line1.StartsWith(prefix))
                    {
                        line1 = reader1.ReadLine();
                        continue;
                    }
                    if (line2 != null && line2.StartsWith(prefix))
                    {
                        line2 = reader2.ReadLine();
                        continue;
                    }

                    // If both lines are not null, compare them
                    if (line1 != null && line2 != null)
                    {
                        if (!line1.Equals(line2, StringComparison.Ordinal))
                            return false;

                        // Advance to the next lines
                        line1 = reader1.ReadLine();
                        line2 = reader2.ReadLine();
                    }
                    // If only one line is null, then the strings are not equal
                    else if (line1 != null || line2 != null)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        #region Sources for generator tests

        private static List<(string path, string text)> GetSourcesForSimpleLazinator()
        {
            var mainProgramSource = @"
namespace MyCode
{
    public class Program
    {
        public static void Main(string[] args)
        {
        }
    }
}";


            var interfaceSource = @"
using Lazinator.Attributes;

namespace MyCode
{
    [Lazinator((int)1)]
    public interface IMyExample
    {
        int MyInt { get; set; }
    }
}";

            var classSource = @"
namespace MyCode
{
    public partial class MyExample : IMyExample
    {
    }
}";

            var sources = new List<(string path, string text)>()
            {
                ("Program.cs", mainProgramSource),
                ("IMyExample.cs", interfaceSource),
                ("MyExample.cs", classSource)
            };
            return sources;
        }

        private static List<(string path, string text)> GetSourcesUsingNonLazinator()
        {
            var mainProgramSource = @"
namespace MyCode
{
    public class Program
    {
        public static void Main(string[] args)
        {
        }
    }
}";

            // we'll do something wrong by having a Lazinator interface refer to a non-Lazinator class.
            var nonlazinatorSource = @"
namespace MyCode
{
    public class MyNonLazinator
    {
    
    }
}
";

            // The source code to test
            var interfaceSource = @"
using Lazinator.Attributes;

namespace MyCode
{
    [Lazinator((int)1)]
    public interface IMyExample
    {
        MyNonLazinator MyMistake { get; set; }
    }
}";

            var classSource = @"
namespace MyCode
{
    public partial class MyExample : IMyExample
    {
    }
}";

            var sources = new List<(string path, string text)>()
            {
                ("Program.cs", mainProgramSource),
                ("IMyExample.cs", interfaceSource),
                ("MyExample.cs", classSource)
            };
            return sources;
        }

        private static List<(string path, string text)> ReplaceInSources(List<(string path, string text)> originals, string searchFor, string replaceWith) => originals.Select(x => (x.path, x.text.Replace(searchFor, replaceWith))).ToList();

        #endregion

        #region Generator execution

        public record GeneratorExecutionResult(LazinatorIncrementalGenerator generator, CSharpCompilation compilation, GeneratorDriver driver, List<(string path, string text)> outputs)
        {

        }

        private static GeneratorExecutionResult ExecuteGeneration(IEnumerable<(string path, string text)> sources, IEnumerable<(string path, string text)> additionalTexts, IDateTimeNow dateTimeNowProvider)
        {
            // Parse the provided string into a C# syntax tree
            IEnumerable<SyntaxTree> syntaxTrees = sources.Select(x => CSharpSyntaxTree.ParseText(x.text, path: x.path)).ToArray();

            // Create references for assemblies we required
            IEnumerable<PortableExecutableReference> references = AdhocWorkspaceManager.GetProjectReferences();

            // Create a Roslyn compilation for the syntax tree.
            CSharpCompilation compilation = CSharpCompilation.Create(
                assemblyName: "Tests",
                syntaxTrees: syntaxTrees,
                references: references
                );

            // Create an instance of our incremental source generator
            var generator = new LazinatorIncrementalGenerator() { DateTimeNowProvider = dateTimeNowProvider };

            // The GeneratorDriver is used to run our generator against a compilation
            GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
            driver = AddAdditionalTextsToDriver(additionalTexts, driver);

            // Run the source generator!
            driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out _);

            // Look at the resulting source file
            List<(string path, string text)> outputs = driver.GetRunResult().Results[0].GeneratedSources.Select(x => (x.SyntaxTree.FilePath, x.SourceText.ToString())).ToList();
            return new GeneratorExecutionResult(generator, (CSharpCompilation) outputCompilation, driver, outputs);
        }

        private static GeneratorDriver AddAdditionalTextsToDriver(IEnumerable<(string path, string text)> additionalTexts, GeneratorDriver driver)
        {
            if (additionalTexts != null)
            {
                var additionalTexts2 = ImmutableArray.CreateRange(additionalTexts.Select(x => (AdditionalText)new CustomAdditionalText(x.path, x.text)));
                driver = driver.AddAdditionalTexts(additionalTexts2);
            }

            return driver;
        }

        private static GeneratorExecutionResult AddGeneratedFilesToCompilation(GeneratorExecutionResult executionResult)
        {
            // Add the generated sources to the compilation
            GeneratorDriverRunResult overallRunResult = executionResult.driver.GetRunResult();
            foreach (var specificRunResult in overallRunResult.Results)
            {
                foreach (var source in specificRunResult.GeneratedSources)
                {
                    SyntaxTree tree = CSharpSyntaxTree.ParseText(source.SourceText);
                    var revisedCompilation = executionResult.compilation.AddSyntaxTrees(tree);
                    executionResult = executionResult with { compilation = revisedCompilation };
                }
            }
            return executionResult;
        }

        private static GeneratorExecutionResult ReplaceFileWithUpdatedVersion(GeneratorExecutionResult executionResult, string path, string text)
        {
            SyntaxTree oldTree = executionResult.compilation.SyntaxTrees.FirstOrDefault(x => x.FilePath == path);
            if (oldTree == null)
                throw new Exception("Source didn't exist as expected.");
            executionResult = executionResult with { compilation = executionResult.compilation.RemoveSyntaxTrees(oldTree) };
            SyntaxTree newTree = CSharpSyntaxTree.ParseText(text, null, path);
            executionResult = executionResult with { compilation = executionResult.compilation.AddSyntaxTrees(newTree) };
            return executionResult;
        }
    }

    public static class ModuleInitializer
    {
        // DEBUG -- I think this whole thing can be deleted and we can remove Verify.SourceGenerators
        [ModuleInitializer]
        public static void Init()
        {
            //VerifySourceGenerators.Enable();
        }
    }

    public class CustomAdditionalText : AdditionalText
    {
        private readonly string _text;

        public override string Path { get; }

        public CustomAdditionalText(string path, string text)
        {
            Path = path;
            _text = text ?? File.ReadAllText(path);
        }

        public override SourceText GetText(CancellationToken cancellationToken = new CancellationToken())
        {
            return SourceText.From(_text);
        }

        #endregion
    }
}
