using LazinatorCodeGen.Roslyn;
using LazinatorGenerator.Settings;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Reflection.Metadata;
using System.Reflection;
using System.Text;
using System.Threading.Channels;

namespace LazinatorGenerator.Generator
{
    [Generator]
    /// Define the incremental generator, creating a pipeline to take maximum advantage of caching to avoid unnecessary repetitive code generation.
    /// (1) IncrementalGeneratorInitializationContext: We initialize two incremental values providers, one for the syntax contexts for our interfaces decorated with the LazinatorAttribute and one for the config files. Then we combine these, and we choose the appropriate config file for each syntax context. Combine these for each syntax context and its config file into a LazinatorPreGenerationInfo. Note that if there has been no change to the syntax context or its config file, the LazinatorPreGenerationInfo will be loaded from the cache. 
    /// (2) LazinatorPreGenerationInfo -> LazinatorPostGenerationInfo. At this step, we actually perform the source generation. We also use the information generated by the source generation to create a list of dependencies for each generated Lazinator object, i.e. a list of other objects that, if relevantly changed, will necessitate regeneration of the Lazinator code. At this point, the LazinatorPostGenerationInfo that is generated contains a list of dependencies, but it does not contain any information (i.e., hash codes) about the status of those dependencies. Note that if this has occurred previously and nothing has changed, then the LazinatorPostGenerationInfo will be loaded from the cache, thus potentially saving us the very demanding step of code generation. But we need to be careful, because we don't want to use the cached source generation if any of the config files have changed.
    /// (3) ImmutableArray<LazinatorPostGenerationInfo> -> individual LazinatorPostGenerationInfo, with dependency hashes. We combine all LazinatorPostGenerationInfos into an immutable array. Note that if nothing at all has changed, then the source to be generated from that ImmutableArray will be cached. If it is not cached, however, we will then run code that creates a new IncrementalValueProvider<LazinatorPostGenerationInfo> corresponding to the immutable array, but containing hash codes for any dependencies included in the immutable array. Thus, whether Object X has changed or not, if it is dependent on Object Y (perhaps a base class, for example), and Object Y's generated code has changed, then the new LazinatorPostGenerationInfo produced will be different from any past LazinatorPostGenerationInfo.
    /// (4) LazinatorPostGenerationInfo -> Generated code. If the LazinatorPostGenerationInfo has not changed, then the cached version will automatically be used. If LazinatorPostGenerationInfo is asked to generate code, meaning that it has changed in some way, then it must determine whether Step 2 actually ran on this step to create this object (in which case the generated code can just be returned, as it will reflect the state of all dependencies and that will help to avoid generating code twice) or was skipped in favor of a cached result (in which case the code must be generated at this point). It makes this determination by checking the PipelineRunUniqueID. If the PipelineRunUniqueID is the same as the PipelineRunUniqueID of the LazinatorPostGenerationInfo, then the code was already generated during this pipeline run and can be returned.  
    public class LazinatorIncrementalGenerator : IIncrementalGenerator
    {
        public static Guid PipelineRunUniqueID = default;
        
        public void Initialize(IncrementalGeneratorInitializationContext 
context)
        {

            // Find the syntax contexts (i.e., interface declarations decorated with LazinatorAttribute)
            IncrementalValuesProvider<GeneratorAttributeSyntaxContext> syntaxContexts = context.SyntaxProvider
                          .ForAttributeWithMetadataName("Lazinator.Attributes.LazinatorAttribute", IsSyntaxTargetForGeneration, (ctx, cancellationToken) => ctx); // Note: We stick with the GeneratorAttributeSyntaxContext for now, so that we can combine with the LazinatorConfig.

            // For each syntax context, we need the appropriate LazinatorConfig. We will use the config file in the same directory as the source file, if it exists, or in the closest parent/ancestor directory, or the default config. 
            // Find our LazinatorConfig.json and Lazinatorconfig.json files.
            IncrementalValuesProvider<AdditionalText> additionalTextsProvider = context.AdditionalTextsProvider
                .Where((Func<AdditionalText, bool>)(x => PathMatches(x)));

            static bool PathMatches(AdditionalText x)
            {
                return x.Path.EndsWith(LazinatorConfigLoader.ConfigFileName) || x.Path.EndsWith(LazinatorConfigLoader.AltConfigFileName);
            }
            /// Extract the path and text from each of these. 
            IncrementalValuesProvider<(string path, string text)> additionalTextsPathAndContents = additionalTextsProvider.Select<AdditionalText, (string path, string text)>((additionalText, cancellationToken) =>
            {
                string filePath = additionalText.Path.TrimEnd(Path.DirectorySeparatorChar);
                string fileText = additionalText.GetText(cancellationToken).ToString();
                return (filePath, fileText);
            });
            // Parse the JSON to generate LazinatorConfig objects, placed into an ImmutableArray. Note that we have designed LazinatorConfig to have fast hashing, so that the generator can use appropriate caching efficiently.
            IncrementalValueProvider<ImmutableArray<LazinatorConfig>> configLocationsAndContents = additionalTextsPathAndContents.Where(x => x.path != null).Select((x, cancellationToken) => new LazinatorConfig(x.path, x.text)).Collect();
            // Slight detour: We need to have a Guid for each run through the pipeline. Since this is a point where we just have one object (the immutable array), it's a good place to call Guid.NewGuid(), since we don't want to call it once per object. 
            IncrementalValueProvider<ImmutableArray<LazinatorConfig>> configLocationsAndContents2 = configLocationsAndContents.Select((x, cancellationToken) =>
            {
                PipelineRunUniqueID = Guid.NewGuid();
                return x;
            });
            // Back to our config files: Now, we store the SyntaxContext and the applicable configuration file. It may seem tempting to defer choosing the appropriate source until we know that we need to generate the source, to save time early in the pipeline, but then changing any config file would force regeneration of every file in the project.
            IncrementalValuesProvider<(GeneratorAttributeSyntaxContext SyntaxContext, ImmutableArray<LazinatorConfig> ConfigFiles)> sourcesConfigsAndID = syntaxContexts.Combine(configLocationsAndContents2).Select((x, cancellationToken) => (x.Left, x.Right));
            IncrementalValuesProvider<LazinatorPreGenerationInfo> preGenerationInfos = sourcesConfigsAndID.Select((x, cancellationToken) => new LazinatorPreGenerationInfo(x.SyntaxContext, ChooseAppropriateConfig(Path.GetDirectoryName(x.SyntaxContext.TargetNode.SyntaxTree.FilePath), x.ConfigFiles)));
            // Create a LazinatorPostGenerationInfo for each preGenerationInfo that hasn't been cached.
            IncrementalValuesProvider<LazinatorPostGenerationInfo> postGenerationInfos = preGenerationInfos.Select((x, cancellationToken) => new LazinatorPostGenerationInfo(x, x.ExecuteSourceGeneration(PipelineRunUniqueID))).Where(x => !x.AlreadyGeneratedCode.IsEmpty);
            IncrementalValueProvider<ImmutableArray<LazinatorPostGenerationInfo>> postGenerationInfosCollected = postGenerationInfos.Collect();
            IncrementalValuesProvider<LazinatorPostGenerationInfo> postGenerationInfosSeparated = postGenerationInfosCollected.SelectMany((x, cancellationToken) => LazinatorPostGenerationInfo.SeparateForNextPipelineStep(x));
            // Generate the source using the compilation and enums
            context.RegisterSourceOutput(postGenerationInfosSeparated,
                static (spc, postGenerationInfo) => postGenerationInfo.GenerateSource(spc, PipelineRunUniqueID));
        }

        static (string allPropertyDeclarations, ImmutableArray<string> namesOfTypesReliedOn) GetPropertiesTypeInfo(GeneratorAttributeSyntaxContext context)
        {
            var propertiesListedHere = String.Join(";", context.TargetNode.DescendantNodes().OfType<PropertyDeclarationSyntax>().Select(x => x.ToString()));
            ((INamedTypeSymbol)context.TargetSymbol).GetPropertiesForType(false, out var propertiesThisLevel, out var propertiesLowerLevel);
            var allPropertyTypeNames = propertiesThisLevel.Select(x => x.Type.GetFullyQualifiedName(false)).ToList();
            allPropertyTypeNames.AddRange(propertiesLowerLevel.Select(x => x.Type.GetFullyQualifiedName(false)));
            var allPropertyTypeNamesArray = allPropertyTypeNames.Distinct().ToArray();
            ImmutableArray<string> propertyTypeNamesImmutable = ImmutableArray.Create<string>(allPropertyTypeNamesArray);
            return (propertiesListedHere, propertyTypeNamesImmutable);
        }

        static LazinatorConfig ChooseAppropriateConfig(string path, ImmutableArray<LazinatorConfig> candidateConfigs)
        {
            LazinatorConfig? bestConfigSoFar = null;
            for (int i = 0; i < candidateConfigs.Length; i++)
            {
                string candidateConfigPath = candidateConfigs[i].ConfigFilePath;
                if (candidateConfigPath.Length >= (bestConfigSoFar?.ConfigFilePath.Length ?? 0) && path.StartsWith(candidateConfigPath))
                    bestConfigSoFar = candidateConfigs[i];
            }
            return bestConfigSoFar ?? new LazinatorConfig();
        }

        static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken cancellationToken)
        {
            return node is InterfaceDeclarationSyntax m && m.AttributeLists.Count > 0;
        }


    }

    
}